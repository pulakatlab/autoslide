#!/usr/bin/env python3
"""
GUI for validating masks generated by the AutoSlide pipeline.

Displays original images, masks, and overlays for quick validation.
Supports keyboard navigation and marking images for review.
"""

import os
import sys
import json
import argparse
from pathlib import Path
from typing import List, Tuple, Optional
import tkinter as tk
from tkinter import filedialog, messagebox
from PIL import Image, ImageTk, ImageDraw
import numpy as np


class MaskValidationGUI:
    def __init__(self, root: tk.Tk, directory: str):
        self.root = root
        self.root.title("Mask Validation GUI")
        self.directory = Path(directory)
        
        # State
        self.image_files: List[Path] = []
        self.current_index = 0
        self.dropped_masks: set = set()
        self.dropped_images: set = set()
        self.validation_file = self.directory / "validation_results.json"
        self.unsaved_changes = False
        self.autosave_interval = 30000  # 30 seconds in milliseconds
        self.binarize_mask = tk.BooleanVar(value=False)
        self.force_recreate_overlay = tk.BooleanVar(value=False)
        
        # Load existing validation results
        self.load_validation_results()
        
        # Find all images
        self.load_images()
        
        if not self.image_files:
            messagebox.showerror("Error", "No images found in the specified directory")
            sys.exit(1)
        
        # Setup UI
        self.setup_ui()
        
        # Bind keyboard events
        self.root.bind('<Up>', lambda e: self.navigate(-1))
        self.root.bind('<Down>', lambda e: self.navigate(1))
        self.root.bind('<Left>', lambda e: self.drop_mask())
        self.root.bind('<Right>', lambda e: self.drop_image())
        self.root.bind('<q>', lambda e: self.quit_app())
        self.root.bind('<s>', lambda e: self.save_validation_results())
        self.root.bind('<b>', lambda e: self.toggle_binarize())
        self.root.bind('<o>', lambda e: self.toggle_force_recreate_overlay())
        
        # Start autosave timer
        self.schedule_autosave()
        
        # Load first image
        self.display_current_image()
    
    def setup_ui(self):
        """Create the GUI layout."""
        # Main container
        main_frame = tk.Frame(self.root)
        main_frame.pack(fill=tk.BOTH, expand=True, padx=10, pady=10)
        
        # Info panel at top
        info_frame = tk.Frame(main_frame)
        info_frame.pack(fill=tk.X, pady=(0, 10))
        
        self.info_label = tk.Label(
            info_frame,
            text="",
            font=("Arial", 10),
            anchor="w"
        )
        self.info_label.pack(side=tk.LEFT, fill=tk.X, expand=True)
        
        self.status_label = tk.Label(
            info_frame,
            text="",
            font=("Arial", 10, "bold"),
            anchor="e"
        )
        self.status_label.pack(side=tk.RIGHT)
        
        # Image display area
        images_frame = tk.Frame(main_frame)
        images_frame.pack(fill=tk.BOTH, expand=True)
        
        # Three columns for original, mask, and overlay
        self.original_frame = self.create_image_panel(images_frame, "Original Image")
        self.mask_frame = self.create_image_panel(images_frame, "Mask")
        self.overlay_frame = self.create_image_panel(images_frame, "Overlay")
        
        # Control panel at bottom
        control_frame = tk.Frame(main_frame)
        control_frame.pack(fill=tk.X, pady=(10, 0))
        
        # Options frame (left side)
        options_frame = tk.Frame(control_frame)
        options_frame.pack(side=tk.LEFT)
        
        # Binarize checkbox
        binarize_checkbox = tk.Checkbutton(
            options_frame,
            text="Binarize Mask (B)",
            variable=self.binarize_mask,
            command=self.on_binarize_changed
        )
        binarize_checkbox.pack(side=tk.LEFT, padx=(0, 10))
        
        # Force recreate overlay checkbox
        recreate_overlay_checkbox = tk.Checkbutton(
            options_frame,
            text="Force Recreate Overlay (O)",
            variable=self.force_recreate_overlay,
            command=self.on_force_recreate_overlay_changed
        )
        recreate_overlay_checkbox.pack(side=tk.LEFT, padx=(0, 20))
        
        # Navigation buttons
        nav_frame = tk.Frame(control_frame)
        nav_frame.pack(side=tk.LEFT)
        
        tk.Button(
            nav_frame,
            text="↑ Previous (Up)",
            command=lambda: self.navigate(-1),
            width=15
        ).pack(side=tk.LEFT, padx=2)
        
        tk.Button(
            nav_frame,
            text="↓ Next (Down)",
            command=lambda: self.navigate(1),
            width=15
        ).pack(side=tk.LEFT, padx=2)
        
        # Action buttons
        action_frame = tk.Frame(control_frame)
        action_frame.pack(side=tk.RIGHT)
        
        tk.Button(
            action_frame,
            text="← Drop Mask (Left)",
            command=self.drop_mask,
            bg="#ffcccc",
            width=18
        ).pack(side=tk.LEFT, padx=2)
        
        tk.Button(
            action_frame,
            text="→ Drop Image Set (Right)",
            command=self.drop_image,
            bg="#ffaaaa",
            width=20
        ).pack(side=tk.LEFT, padx=2)
        
        tk.Button(
            action_frame,
            text="Save (S)",
            command=self.save_validation_results,
            bg="#ccffcc",
            width=12
        ).pack(side=tk.LEFT, padx=2)
        
        # Instructions at bottom
        instructions = (
            "Navigation: ↑/↓ arrows | "
            "Actions: ← drop mask, → drop entire image set | "
            "Options: B toggle binarize, O toggle recreate overlay | "
            "Save: S | Quit: Q"
        )
        tk.Label(
            main_frame,
            text=instructions,
            font=("Arial", 9),
            fg="gray"
        ).pack(pady=(5, 0))
    
    def create_image_panel(self, parent: tk.Frame, title: str) -> dict:
        """Create a panel for displaying an image."""
        frame = tk.Frame(parent, relief=tk.RIDGE, borderwidth=2)
        frame.pack(side=tk.LEFT, fill=tk.BOTH, expand=True, padx=5)
        
        title_label = tk.Label(frame, text=title, font=("Arial", 12, "bold"))
        title_label.pack(pady=5)
        
        canvas = tk.Canvas(frame, bg="gray")
        canvas.pack(fill=tk.BOTH, expand=True, padx=5, pady=5)
        
        return {"frame": frame, "title": title_label, "canvas": canvas}
    
    def load_images(self):
        """Find all images in the directory and subdirectories."""
        # Look for images in the standard pipeline structure
        images_dirs = list(self.directory.rglob("images"))
        
        if not images_dirs:
            # Fallback: look for PNG files directly
            self.image_files = sorted(self.directory.glob("*.png"))
        else:
            # Use the first images directory found
            for images_dir in images_dirs:
                image_files = sorted(images_dir.glob("*.png"))
                # Filter out mask and overlay files
                image_files = [
                    f for f in image_files
                    if not f.name.endswith("_mask.png") and not f.name.endswith("_overlay.png")
                ]
                if image_files:
                    self.image_files.extend(image_files)
        
        if not self.image_files:
            # Last resort: all PNG files
            self.image_files = sorted(self.directory.rglob("*.png"))
            self.image_files = [
                f for f in self.image_files
                if not f.name.endswith("_mask.png") and not f.name.endswith("_overlay.png")
            ]
    
    def get_mask_path(self, image_path: Path) -> Path:
        """Get the corresponding mask path for an image."""
        mask_path = Path(str(image_path).replace('/images/', '/masks/'))
        mask_path = mask_path.parent / mask_path.name.replace('.png', '_mask.png')
        return mask_path
    
    def get_overlay_path(self, image_path: Path) -> Path:
        """Get the corresponding overlay path for an image."""
        overlay_path = Path(str(image_path).replace('/images/', '/overlays/'))
        overlay_path = overlay_path.parent / overlay_path.name.replace('.png', '_overlay.png')
        return overlay_path
    
    def load_and_resize_image(self, path: Path, max_size: Tuple[int, int] = (400, 400), draw_x: bool = False, binarize: bool = False) -> Optional[ImageTk.PhotoImage]:
        """Load an image and resize it to fit the display."""
        if not path.exists():
            return None
        
        try:
            img = Image.open(path)
            
            # Binarize if requested (similar to calc_fibrosis.py)
            if binarize:
                # Convert to grayscale if needed
                if img.mode != 'L':
                    if len(np.array(img).shape) == 3:
                        img_array = np.array(img)
                        if img_array.shape[2] > 1:
                            img_array = img_array[..., 0]  # Take first channel
                        img = Image.fromarray(img_array, mode='L')
                    else:
                        img = img.convert('L')
                
                # Convert to numpy array and binarize
                img_array = np.array(img)
                if img_array.dtype != np.uint8:
                    img_array = (img_array * 255).astype(np.uint8)
                
                # Binarize: convert to 0 or 255
                binary_array = (img_array > 0).astype(np.uint8) * 255
                img = Image.fromarray(binary_array, mode='L')
            
            # Calculate resize ratio to fit within max_size while maintaining aspect ratio
            ratio = min(max_size[0] / img.width, max_size[1] / img.height)
            if ratio < 1:
                new_size = (int(img.width * ratio), int(img.height * ratio))
                img = img.resize(new_size, Image.Resampling.LANCZOS)
            
            # Draw red diagonal lines if requested
            if draw_x:
                img = self.draw_red_x(img)
            
            return ImageTk.PhotoImage(img)
        except Exception as e:
            print(f"Error loading image {path}: {e}")
            return None
    
    def draw_red_x(self, img: Image.Image) -> Image.Image:
        """Draw red diagonal lines across an image."""
        img_copy = img.copy()
        draw = ImageDraw.Draw(img_copy)
        width, height = img_copy.size
        
        # Draw thick red diagonal lines
        line_width = max(5, min(width, height) // 100)
        draw.line([(0, 0), (width, height)], fill="red", width=line_width)
        draw.line([(width, 0), (0, height)], fill="red", width=line_width)
        
        return img_copy
    
    def create_overlay_from_mask(self, image_path: Path, mask_path: Path, draw_x: bool = False, binarize_mask: bool = False) -> Optional[ImageTk.PhotoImage]:
        """Create an overlay image with mask at 0.3 alpha if overlay doesn't exist."""
        if not image_path.exists() or not mask_path.exists():
            return None
        
        try:
            # Load images
            img = Image.open(image_path).convert("RGBA")
            mask = Image.open(mask_path).convert("L")
            
            # Binarize mask if requested (similar to calc_fibrosis.py)
            mask_array = np.array(mask)
            if binarize_mask:
                if mask_array.dtype != np.uint8:
                    mask_array = (mask_array * 255).astype(np.uint8)
                # Binarize: convert to 0 or 255
                mask_array = (mask_array > 0).astype(np.uint8) * 255
            
            # Create colored mask (red with alpha)
            mask_colored = Image.new("RGBA", img.size, (255, 0, 0, 0))
            
            # Apply alpha based on mask values
            mask_rgba = np.zeros((*mask_array.shape, 4), dtype=np.uint8)
            mask_rgba[..., 0] = 255  # Red channel
            mask_rgba[..., 3] = (mask_array * 0.3).astype(np.uint8)  # Alpha at 0.3
            
            mask_colored = Image.fromarray(mask_rgba, "RGBA")
            
            # Composite
            overlay = Image.alpha_composite(img, mask_colored)
            
            # Resize
            max_size = (400, 400)
            ratio = min(max_size[0] / overlay.width, max_size[1] / overlay.height)
            if ratio < 1:
                new_size = (int(overlay.width * ratio), int(overlay.height * ratio))
                overlay = overlay.resize(new_size, Image.Resampling.LANCZOS)
            
            # Draw red X if requested
            if draw_x:
                overlay = self.draw_red_x(overlay)
            
            return ImageTk.PhotoImage(overlay)
        except Exception as e:
            print(f"Error creating overlay: {e}")
            return None
    
    def display_current_image(self):
        """Display the current image, mask, and overlay."""
        if not self.image_files:
            return
        
        image_path = self.image_files[self.current_index]
        mask_path = self.get_mask_path(image_path)
        overlay_path = self.get_overlay_path(image_path)
        
        # Determine what to mark with red X
        image_dropped = str(image_path) in self.dropped_images
        mask_dropped = str(image_path) in self.dropped_masks
        
        # Update info label
        self.info_label.config(
            text=f"Image {self.current_index + 1}/{len(self.image_files)}: {image_path.name}"
        )
        
        # Update status label
        status_parts = []
        if image_dropped:
            status_parts.append("IMAGE DROPPED")
        if mask_dropped:
            status_parts.append("MASK DROPPED")
        
        if status_parts:
            self.status_label.config(text=" | ".join(status_parts), fg="red")
        else:
            self.status_label.config(text="OK", fg="green")
        
        # Load and display original image (with X if entire image set dropped)
        original_img = self.load_and_resize_image(image_path, draw_x=image_dropped)
        self.display_image_on_canvas(self.original_frame["canvas"], original_img, "Original not found")
        
        # Load and display mask (with X if mask or entire image dropped)
        mask_img = self.load_and_resize_image(
            mask_path, 
            draw_x=(mask_dropped or image_dropped),
            binarize=self.binarize_mask.get()
        )
        self.display_image_on_canvas(self.mask_frame["canvas"], mask_img, "Mask not found")
        
        # Load and display overlay (or create it) (with X if mask or entire image dropped)
        if overlay_path.exists() and not self.force_recreate_overlay.get():
            overlay_img = self.load_and_resize_image(overlay_path, draw_x=(mask_dropped or image_dropped))
        else:
            overlay_img = self.create_overlay_from_mask(
                image_path, mask_path, 
                draw_x=(mask_dropped or image_dropped),
                binarize_mask=self.binarize_mask.get()
            )
        self.display_image_on_canvas(self.overlay_frame["canvas"], overlay_img, "Overlay not available")
    
    def display_image_on_canvas(self, canvas: tk.Canvas, photo_image: Optional[ImageTk.PhotoImage], error_msg: str):
        """Display an image on a canvas or show error message."""
        canvas.delete("all")
        
        if photo_image:
            # Keep a reference to prevent garbage collection
            canvas.image = photo_image
            canvas.create_image(
                canvas.winfo_width() // 2,
                canvas.winfo_height() // 2,
                image=photo_image,
                anchor=tk.CENTER
            )
        else:
            canvas.create_text(
                canvas.winfo_width() // 2,
                canvas.winfo_height() // 2,
                text=error_msg,
                fill="white",
                font=("Arial", 12)
            )
    
    def navigate(self, direction: int):
        """Navigate to the next or previous image."""
        self.current_index = (self.current_index + direction) % len(self.image_files)
        self.display_current_image()
    
    def drop_mask(self):
        """Mark the current mask as dropped."""
        if not self.image_files:
            return
        
        image_path = str(self.image_files[self.current_index])
        
        if image_path in self.dropped_masks:
            self.dropped_masks.remove(image_path)
        else:
            self.dropped_masks.add(image_path)
        
        self.unsaved_changes = True
        self.display_current_image()
    
    def drop_image(self):
        """Mark the entire image set as dropped."""
        if not self.image_files:
            return
        
        image_path = str(self.image_files[self.current_index])
        
        if image_path in self.dropped_images:
            self.dropped_images.remove(image_path)
        else:
            self.dropped_images.add(image_path)
        
        self.unsaved_changes = True
        self.display_current_image()
    
    def load_validation_results(self):
        """Load existing validation results from JSON file."""
        if self.validation_file.exists():
            try:
                with open(self.validation_file, 'r') as f:
                    data = json.load(f)
                    self.dropped_masks = set(data.get("dropped_masks", []))
                    self.dropped_images = set(data.get("dropped_images", []))
            except Exception as e:
                print(f"Error loading validation results: {e}")
    
    def save_validation_results(self, show_message: bool = True):
        """Save validation results to JSON file."""
        try:
            data = {
                "dropped_masks": sorted(list(self.dropped_masks)),
                "dropped_images": sorted(list(self.dropped_images)),
                "total_images": len(self.image_files),
                "num_dropped_masks": len(self.dropped_masks),
                "num_dropped_images": len(self.dropped_images)
            }
            
            with open(self.validation_file, 'w') as f:
                json.dump(data, f, indent=2)
            
            self.unsaved_changes = False
            
            if show_message:
                messagebox.showinfo(
                    "Saved",
                    f"Validation results saved to:\n{self.validation_file}\n\n"
                    f"Dropped masks: {len(self.dropped_masks)}\n"
                    f"Dropped images: {len(self.dropped_images)}"
                )
        except Exception as e:
            if show_message:
                messagebox.showerror("Error", f"Failed to save validation results: {e}")
            else:
                print(f"Autosave error: {e}")
    
    def schedule_autosave(self):
        """Schedule periodic autosave."""
        if self.unsaved_changes:
            self.save_validation_results(show_message=False)
            print(f"Autosaved at {self.current_index + 1}/{len(self.image_files)}")
        
        # Schedule next autosave
        self.root.after(self.autosave_interval, self.schedule_autosave)
    
    def toggle_binarize(self):
        """Toggle the binarize mask option."""
        self.binarize_mask.set(not self.binarize_mask.get())
        self.display_current_image()
    
    def on_binarize_changed(self):
        """Handle binarize checkbox change."""
        self.display_current_image()
    
    def toggle_force_recreate_overlay(self):
        """Toggle the force recreate overlay option."""
        self.force_recreate_overlay.set(not self.force_recreate_overlay.get())
        self.display_current_image()
    
    def on_force_recreate_overlay_changed(self):
        """Handle force recreate overlay checkbox change."""
        self.display_current_image()
    
    def quit_app(self):
        """Quit the application with confirmation."""
        if self.unsaved_changes:
            response = messagebox.askyesnocancel(
                "Save before quit?",
                "You have unsaved changes. Save before quitting?"
            )
            if response is None:  # Cancel
                return
            elif response:  # Yes
                self.save_validation_results(show_message=False)
        
        self.root.quit()


def main():
    parser = argparse.ArgumentParser(
        description="GUI for validating masks generated by the AutoSlide pipeline"
    )
    parser.add_argument(
        "directory",
        nargs="?",
        help="Directory containing images and masks (will prompt if not provided)"
    )
    
    args = parser.parse_args()
    
    # Get directory
    if args.directory:
        directory = args.directory
    else:
        root = tk.Tk()
        root.withdraw()
        directory = filedialog.askdirectory(title="Select directory containing images")
        root.destroy()
        
        if not directory:
            print("No directory selected. Exiting.")
            sys.exit(1)
    
    # Verify directory exists
    if not os.path.isdir(directory):
        print(f"Error: Directory not found: {directory}")
        sys.exit(1)
    
    # Create and run GUI
    root = tk.Tk()
    root.geometry("1400x800")
    app = MaskValidationGUI(root, directory)
    root.mainloop()


if __name__ == "__main__":
    main()
